<!DOCTYPE html><html lang="en"><head><title>Архитектура компьютера и операционные системы</title><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../../common/shower/themes/ribbon/styles/screen-16x10.css"><style type="text/css">.caption {
    color: #FFF;
}</style></head><body class="shower list"><header class="caption"><h1>Архитектура компьютера и операционные системы</h1><p>Семинар 15. Отображение файлов в память</p></header><section id="cover" class="slide"><h2>Семинар 15. Отображение файлов в память</h2><p>Архитектура компьютера и операционные системы @ ВШЭ, 2018-2019</p><img src="./img/cover.jpg" alt="" class="cover"><style type="text/css">#cover h2 {
    margin: 30px 0 0;
    color: #FFF;
    text-align: center;
    font-size: 70px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p {
    margin: 10px 0 0;
    text-align: center;
    color: #FFF;
    font-style: italic;
    font-size: 20px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p a {
    color: #FFF;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
</style></section><section class="slide"><h2>Управление адресным пространством процесса</h2><ul><li><a href="https://www.opennet.ru/man.shtml?topic=sbrk&amp;category=2&amp;russian=0">Системный вызов brk</a></li><li>Позволяет установить конец сегмента данных</li><li>Один из способов, которыми можно реализовать <code>malloc</code> (однако, не самый лучший)</li></ul></section><section class="slide"><h2>Системный вызов mmap</h2><ul><li><code>mmap</code>, <code>munmap</code> - отражает файлы или устройства в памяти или снимает их отражение</li><li>Подробная документация - в <a href="https://www.opennet.ru/man.shtml?topic=mmap&amp;category=2&amp;russian=0">man</a></li><li>Позволяет читать из файла и писать в файл просто взаимодействуя с оперативной памятью</li><li>Синхронизация с диском определяется ядром, однако можно этим управлять с помощью <a href="https://www.opennet.ru/man.shtml?topic=msync&amp;category=2&amp;russian=0">msync</a></li></ul></section><section class="slide"><h2>Системный вызов mmap</h2><ul><li>Заголовочный файл - <code>sys/mman.h</code></li><li><code style="font-size: 15pt;"> void * mmap(void *start, size_t length, int prot , int flags, int fd, off_t offset);</code></li><li><code>start</code> - желаемый адрес начала отображения, <code>length</code> - размер области, <code>prot</code> - флаги <code>PROT_EXEC</code>, <code>PROT_READ</code> и <code>PROT_WRITE</code>, <code>fd</code> - файловый дескриптор (или -1 иногда), <code>offset</code> - смещение в файле</li></ul></section><section class="slide"><h2>Системный вызов munmap</h2><ul><li>Заголовочный файл - <code>sys/mman.h</code></li><li><code style="font-size: 15pt;">int munmap(void *start, size_t length);</code></li><li>Отключает отображение по адресу <code>start</code> размера <code>length</code></li></ul></section><section class="slide"><h2>Флаги mmap</h2><ul><li><code>MAP_SHARED</code> - разделяемое отображение, изменения отображаются обратно в файл</li><li><code>MAP_PRIVATE</code> - неразделяемое отображение, COPY-ON-WRITE</li><li><code>MAP_ANONYMOUS</code> - анонимное отображение (не соответствует никакому файлу)</li><li><code>MAP_NORESERVE</code> - используется с <code>MAP_PRIVATE</code>, не выделяет страницы пространства подкачки для этого отображения</li><li><code>MAP_FIXED</code> - не размещать по адресам, отличным от <code>start</code></li></ul></section><section class="slide"><h2>Особенности mmap</h2><ul><li>Гранулярность работы - одна страница памяти (x86 - 4 KiB)</li><li>Смещение <code>offset</code> должно быть кратно размеру страницы</li><li>Файл не должен быть пустым</li><li>Хвост файла отображается на целую страницу</li></ul></section><section class="slide"><h2>Типичное использование</h2><ul><li><code>MAP_SHARED</code> - несколько процессов будут видеть одну и ту же память</li><li><code>MAP_PRIVATE</code> - другие процессы не увидят изменений в файле, подходит для исполняемых файлов</li><li><code>MAP_SHARED | MAP_ANONYMOUS</code> - общая память для процесса и потомков</li><li><code>MAP_PRIVATE | MAP_ANONYMOUS</code> - содержимое памяти видно только для одного процесса - доп. память в адресном пространстве</li></ul></section><section class="slide"><h2>Адресное пространство в Linux</h2><ul><li>Логическое отображение - <code>/proc/$PID/maps</code> (<a href="https://stackoverflow.com/questions/1401359/understanding-linux-proc-id-maps">объяснение</a>)</li><li>Физическое отображение - <code>/proc/$PID/pagemap</code> (<a href="https://www.kernel.org/doc/Documentation/vm/pagemap.txt">объяснение</a>)</li><li>Если страница есть в логическом отображении, но нет в физическом, то при первом обращении к этой странице ядро выделит новую физическую страницу ОЗУ или возьмет существующую и добавит ее в физическое отображение</li></ul></section><section class="slide"><h2>Адресное пространство в Linux</h2><ul><li>Процесс начинает работу с настроенным логическим отображением и пустым физическим отображением</li><li>Постепенно по мере обращения к страницам заполняется физическое отображение</li><li>Если к странице не было обращений, она не будет загружена в физическую память</li></ul></section><section class="slide"><h2>Адресное пространство в Linux</h2><ul><li>Физические страницы – ценный ресурс, в какой-то момент их может не хватить</li><li>Ядро попытается освободить физические страницы для выполнения текущего запроса</li><li>Если физическая страница соответствует отображению файла в память и не модифицировалась, она просто освобождается</li></ul></section><section class="slide"><h2>Адресное пространство в Linux</h2><ul><li>Страницы MAP_SHARED и модифицированные (dirty) сохраняются в файл и освобождаются</li><li>Прочие страницы сохраняются в файл (раздел) страничной подкачки – swap file</li></ul></section><section class="slide"><h2>Загрузка файла на выполнение</h2><ul><li><code>ELF</code>-файл имеет структуру, оптимизированную для отображения файла <code>mmap</code></li><li>Секция кода (<code>.text</code>) отображается <code>PROT_READ | PROT_EXECUTE</code>, <code>MAP_PRIVATE</code></li><li>Константные данные (<code>.rodata</code>): <code>PROT_READ</code>, <code>MAP_PRIVATE</code></li><li>Данные (<code>.data</code>): <code>PROT_READ | PROT_WRITE</code>, <code>MAP_PRIVATE</code></li><li>Секции <code>.text</code> и <code>.rodata</code> у всех процессов, запущенных из одного файла, будут использовать одни и те же физические страницы памяти</li></ul></section><section class="slide"><h2>Разделяемые библиотеки</h2><ul><li>Позволяют избежать дублирования кода в процессах</li><li>Делает возможным разделять код библиотек между процессами разных исполняемых файлов</li><li>Облегчают обновление ПО</li></ul></section><section class="slide"><h2>Разделяемые библиотеки</h2><ul><li><code>ELF</code>-файл содержит секцию <code>.interp</code>. Эта секция содержит путь к «интерпретатору» - <code>/lib/ld-linux.so.2</code> — загрузчик динамических библиотек</li><li>Загрузчик проходит по списку зависимостей библиотек, находит их в файловой системе и загружает в память, рекурсивно, пока все зависимости не будут удовлетворены</li><li>Загрузка каждой библиотеки аналогична загрузке исполняемого файла (<code>mmap</code>)</li></ul></section><div class="progress"></div><script src="../../../common/shower/shower.min.js"></script></body></html>