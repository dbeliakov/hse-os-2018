<!DOCTYPE html><html lang="en"><head><title>Архитектура компьютера и операционные системы</title><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../../common/shower/themes/ribbon/styles/screen-16x10.css"><style type="text/css">.caption {
    color: #FFF;
}</style></head><body class="shower list"><header class="caption"><h1>Архитектура компьютера и операционные системы</h1><p>Семинар 16. Процессы</p></header><section id="cover" class="slide"><h2>Семинар 16. Процессы</h2><p>Архитектура компьютера и операционные системы @ ВШЭ, 2018-2019</p><img src="./img/cover.jpg" alt="" class="cover"><style type="text/css">#cover h2 {
    margin: 30px 0 0;
    color: #FFF;
    text-align: center;
    font-size: 70px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p {
    margin: 10px 0 0;
    text-align: center;
    color: #FFF;
    font-style: italic;
    font-size: 20px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p a {
    color: #FFF;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
</style></section><section class="slide"><h2>Процессы</h2><ul><li>UNIX - многозадачная операционная система</li><li>Процесс - программа, работающая в некоторый момент времени</li><li>Процесс является субъектом распределения ресурсов в ОС</li></ul></section><section class="slide"><h2>Атрибуты процесса</h2><ul><li>Таблицы страниц виртувльного адресного пространства</li><li>Разделяемые и неразделяемые страницы памяти</li><li>Отображения файлов в память</li><li>Стек ядра</li></ul></section><section class="slide"><h2>Атрибуты процесса</h2><ul><li>Таблица файловых дескрипторов</li><li>Текущий каталог</li><li>Корневой каталог</li><li><a href="https://it.wikireading.ru/3262">Umask процесса</a></li></ul></section><section class="slide"><h2>Атрибуты процесса</h2><ul><li>Динамический и статический приоритеты</li><li>Тип планирования, приоритет реального времени</li></ul></section><section class="slide"><h2>Атрибуты процесса</h2><ul><li>Регистры ЦП</li><li>Командная строка, окружение</li><li>Обработчики сигналов</li><li>Счетчики потребленных ресурсов</li><li>Идентификаторы <code>uid</code>, <code>gid</code>, <code>euid</code>, <code>egid</code> (<a href="http://parallel.uran.ru/book/export/html/396">подробнее</a>)</li></ul></section><section class="slide"><h2>Идентификаторы процессов</h2><ul><li><code>pid</code> — идентификатор процесса, положительное целое число [1..32767] (1 — процесс init)</li><li><code>ppid</code> — идентификатор родительского процесса (если родитель процесса завершается, родителем становится init)</li><li><code>pgid</code> — идентификатор группы процессов (группа процессов выполняет одно задание)</li><li><code>sid</code> — идентификатор сессии (сеанса работы)</li><li><a href="https://stackoverflow.com/questions/6548823/use-and-meaning-of-session-and-process-group-in-unix">Подробнее</a></li></ul></section><section class="slide"><h2>Идентификаторы процессов</h2><ul><li><a href="https://www.opennet.ru/man.shtml?topic=getpid&amp;category=2&amp;russian=0">getpid и getppid</a></li><li>Заголовочный файл <code>unistd.h</code></li><li>Позволяют узнать процессу свои <code>pid</code> и <code>ppid</code></li></ul></section><section class="slide"><h2>Создание процессов</h2><ul><li>Все процессы находятся в древовидной иерархии</li><li>Корень дерева - процесс <code>init</code></li><li><code>init</code> запускает все остальные процессы и имеет <code>pid</code> 1</li></ul></section><section class="slide"><h2>Создание процессов</h2><ul><li>Для создания процесса используется системный вызов <a href="https://www.opennet.ru/man.shtml?topic=fork&amp;category=2">fork</a></li><li>Заголовочный файл - <code>unistd.h</code></li><li>Это единственный способ создания нового процесса</li><li>При ошибке возвращается <code>-1</code>, иначе - <code>pid</code> созданного процесса</li><li>Внутри нового процесса возвращается <code>0</code></li><li>Новый процесс - копия исходного</li></ul></section><section class="slide"><h2>Создание процессов</h2><ul><li>Практически все атрибуты копируются, страницы памяти копируются в режиме copy-on-write</li><li>Не копируются: <code>pid</code>, <code>ppid</code>, сигналы, ожидающие доставки, таймеры, блокировки файлов</li><li>Копируются в том числе и структуры данных, инициализированные стандартной библиотекой</li></ul></section><section class="slide"><h2>Завершение работы процесса</h2><ul><li><code>exit</code> (структуры данных стандартной библиотеки очищаются) и <code>_exit</code> (просто системный вызов)</li><li>Получение сигнала, вызывающего завершение (например, <code>SIGTERM</code>)</li><li>При получении сигнала так же может быть записан образ памяти (core dump)</li></ul></section><section class="slide"><h2>Завершение работы процесса</h2><ul><li>Освобождение страниц памяти, использованных процессом</li><li>Закрытие всех открытых дескрипторов файлов</li><li>Освобождение прочих ресурсов, связанных с процессом, кроме статуса завершения и статистики ресурсов</li><li>Если у процесса есть потомки, родителем потомков назначается процесс <code>init</code></li><li>Родителю процесса посылается сигнал SIGCHLD</li></ul></section><section class="slide"><h2>Ожидание завершения процесса</h2><ul><li><code style="font-size: 15pt;">pid_t wait(int *status);</code> - приостановить выполнение до завершения дочернего процесса</li><li><code style="font-size: 15pt;">pid_t waitpid(pid_t pid, int *status, int options);</code> - приостановить выполнение до завершения дочернего процесса с конкретным <code>pid</code></li><li><a href="https://www.opennet.ru/man.shtml?topic=wait&amp;category=2&amp;russian=0">Подробное описание</a></li><li>Заголовочный файл <code>sys/wait.h</code></li></ul></section><sections class="slide"><h2>Ожидание процесса</h2><ul><li>Процесс-зомби - дочерний процесс в Unix-системе, завершивший своё выполнение, но ещё присутствующий в списке процессов операционной системы, чтобы дать родительскому процессу считать код завершения</li><li>Такие процессы не потребляют ресурсов, однако занимают место в таблице процессов</li></ul></sections><section class="slide"><h2>Подмена программы в процессе</h2><ul><li><code style="font-size: 13pt;">int execve(const char *filename, char *const argv [], char *const envp[]);</code> - выполняет программу, заданную параметром <code>filename</code></li><li>Заголовочный файл <code>unistd.h</code></li><li>Новая программа также наследует от вызвавшего процесса его идентификатор и открытые файловые дескрипторы, на которых не было флага закрыть-при-exec</li><li><a href="https://www.opennet.ru/man.shtml?topic=execve&amp;category=2&amp;russian=0">Подробнее</a></li></ul></section><div class="progress"></div><script src="../../../common/shower/shower.min.js"></script></body></html>