<!DOCTYPE html><html lang="en"><head><title>Архитектура компьютера и операционные системы</title><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../../common/shower/themes/ribbon/styles/screen-16x10.css"><style type="text/css">.caption {
    color: #FFF;
}</style></head><body class="shower list"><header class="caption"><h1>Архитектура компьютера и операционные системы</h1><p>Семинар 11. Введение в ассемблер. Часть 4</p></header><section id="cover" class="slide"><h2>Семинар 11. Введение в ассемблер. Часть 4</h2><p>Архитектура компьютера и операционные системы @ ВШЭ, 2018-2019</p><img src="./img/cover.jpg" alt="" class="cover"><style type="text/css">#cover h2 {
    margin: 30px 0 0;
    color: #FFF;
    text-align: center;
    font-size: 70px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p {
    margin: 10px 0 0;
    text-align: center;
    color: #FFF;
    font-style: italic;
    font-size: 20px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p a {
    color: #FFF;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
</style></section><section class="slide"><h2>Системные вызовы</h2><ul><li>Взаимодействие с железом (вывести на экран, прочитать с диска, сетевое взаимодействие и т.д.) может проводить только ядро ОС</li><li>Пользовательские программы выполняются в пространстве памяти пользователя, к пространству памяти ядра пользователю запрещен доступ</li><li>Системный вызов — способ обращения программы пользовательского пространства к пространству ядра</li></ul></section><section class="slide"><h2>Системные вызовы</h2><ul><li>В архитектуре x86 во время системного вызова как минимум происходит увеличение уровня привилегий, замена пользовательских сегментов на сегменты ядра и установка регистра IP на обработчик системного вызова</li><li>Системные вызовы для высокоуровневых языков обычно обернуты в функции, однако механизм самих системных вызовов отличается</li><li>Теоретически, реализовать syscall можно при помощи любого исключения (деление на 0 и т.д.). Главное — передача управления ядру</li></ul></section><section class="slide"><h2>Реализация системных вызовов</h2><ul><li>Включается защита от чтения/записи/исполнения кода пользовательского пространства</li><li>Заменяется пользовательский стек на стек ядра, сохраняются callee-saved регистры</li><li>Выполняется обработка системного вызова</li><li>Восстановление стека, регистров</li><li>Отключение защиты</li><li>Выход из системного вызова</li></ul></section><section class="slide"><h2>Системный вызов в linux</h2><ul><li>Изначально, в архитектуре x86, Linux использовал программное прерывание 128 для совершения системного вызова</li><li>Для указания номера системного вызова, пользователь задаёт в eax номер системного вызова</li><li>Параметры располагает по порядку в регистрах ebx, ecx, edx, esi, edi, ebp</li><li>Вызывается инструкция int 80h</li><li><a href="https://habr.com/ru/post/347596/">Эволюция системных вызовов</a></li></ul></section><section class="slide"><h2>Некоторые системные вызовы</h2><ul><li><code>void exit(int code);</code> (<code>__NR_exit = 1</code>)</li><li><code>ssize_t read(int fd, void *ptr, size_t size);</code> (<code>__NR_read = 3</code>)</li><li><code>ssize_t write(int fd, const void *ptr, size_t size);</code> (<code>__NR_write = 4</code>)</li></ul></section><section class="slide"><h2>Компиляция без стандартной библиотеки</h2><ul><li>Флаг <code>-nostdlib</code> говорит, что программу не надо линковать со стандартной библиотекой C</li><li>Частью стандартной библиотеки является код инициализации, который выполняет необходимую инициализацию стандартной библиотеки, и затем вызывает <code>main</code></li><li>При компиляции без стандартной библиотеки точка фхода в программу - метка <code>_start</code></li></ul></section><section class="slide"><h2>Компиляция без стандартной библиотеки</h2><ul><li>Ядро передает управление на точку <code>_start</code> не как вызов подпрограммы, то есть для завершения программы нельзя использовать инструкцию <code>ret</code>. Для завершения программы нужно использовать системный вызов <code>exit</code></li><li>Аргументы (argc, argv и env) передаются <a href="http://asm.sourceforge.net/articles/startup.html#st">через стек</a></li><li>В C можно писать функцию <code>void _start()</code>, однако она будет следовать соглашениям о вызовах</li></ul></section><section class="slide"><h2>Ассемблерные вставки</h2><ul><li>Позволяют писать код на ассемблере внутри кода на C</li><li>Инструкция: <code>asm</code> (расширение GNU) или <code>__asm___</code> (рекомендуемо)</li><li>Базовая форма - код на ассемблере вставляется как есть (может быть вне функции, компилятор предполагает, что не меняются ни регистры, ни память)</li><li>Расширенная форма - используются макроподстановки (фактически, можем легко взаимодействовать с внешним кодом)</li></ul></section><section class="slide"><h2>Ассемблерные вставки</h2><ul><li>При использовании расширенной формы можно указывать, где ожидается аргумент (определенный регистр, регистр общего назначения, память и т.п.)</li><li><a href="https://gamedev.ru/code/articles/gcc_inline_asm">Подробно все расписано тут</a></li><li>Неправильно описанная вставка может работать при <code>-O0</code> и <code>-O1</code>, но не работать при <code>-O2</code></li></ul></section><div class="progress"></div><script src="../../../common/shower/shower.min.js"></script></body></html>