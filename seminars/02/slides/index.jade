doctype html
html(lang="en")
    head
        title Архитектура компьютера и операционные системы
        meta(charset="utf-8")
        meta(http-equiv="x-ua-compatible", content="ie=edge")
        meta(name="viewport", content="width=device-width, initial-scale=1")
        link(rel="stylesheet", href="../../../common/shower/themes/ribbon/styles/screen-16x10.css")
        style(type="text/css").
            .caption {
                color: #FFF;
            }
    body.shower.list
        header.caption
            h1 Архитектура компьютера и операционные системы
            p Семинар 2. Стандартный ввод-вывод
        section.slide#cover
            h2 Семинар 2. Стандартный ввод-вывод
            p Архитектура компьютера и операционные системы @ ВШЭ, 2018-2019
            img.cover(src="./img/cover.jpg", alt="")
            style(type="text/css").
                #cover h2 {
                    margin: 30px 0 0;
                    color: #FFF;
                    text-align: center;
                    font-size: 70px;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
                #cover p {
                    margin: 10px 0 0;
                    text-align: center;
                    color: #FFF;
                    font-style: italic;
                    font-size: 20px;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
                #cover p a {
                    color: #FFF;
                    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                                 black -1px 1px 0, black 1px -1px 0;
                }
        section.slide
            h2 Стандартная библиотека C
            ul
                li Функции стандартной библиотеки Си легко вызвать из других языков (в нашем случае, из программы на ассемблере)
                li Стандартная библиотека Си по умолчанию thread-safe (это нам потребуется в дальнейшем)
                li Стандартная библиотека Си (иногда существенно) быстрее
                li Форматный ввод-вывод Си, несмотря на особенности, может оказаться удобнее в использовании
        section.slide
            h2 Стандартные потоки ввода-вывода
            ul
                li Стандартный поток ввода - программа считывает входные данные (условно) с клавиатуры
                li Стандартный поток вывода - программа выводит резуальтаты (условно) на экран
                li Условно - потому что вместо экрана и клавиатуры могут быть разные сущности, и программа об это не узнает
        section.slide
            h2 Стандартные потоки ввода-вывода
            p.
                #[b Текстовый поток] — это последовательность символов, разбитая на строки, каждая из которых содержит нуль
                или более символов и завершается символом новой строки
            p.
                Обязанность следить за тем, чтобы любой поток ввода-вывода отвечал этой модели, возложена на библиотеку:
                программист, пользуясь библиотекой, не должен заботиться о том, в каком виде строки представляются вне программы
        section.slide
            h2 Посимвольные чтение и запись
            ul
                li #[code getchar] - возвращает следующий считанный символ
                li #[code putchar] - печатает символ на стандартный поток вывода
        section.slide
            h2 Посимвольное чтение и запись
            pre
                code(style="font-size: 15pt;").
                    #include &lt;stdio.h&gt;

                    int	getchar(void);		// equivalent to getc(stdin)
                    int	getc(FILE *);		// possibly MACRO, equivalent to fgetc()
                    int	fgetc(FILE *);

                    int putchar(int);		// equivalent to putc(c,stdout)
                    int putc(int, FILE *);	// possibly MACRO, equivalent to fputc()
                    int fputc(int, FILE *);
        section.slide
            h2 Посимвольное чтение и запись
            ul
                li Как отличить конец файла от прочих символов? Использовать значение, которое не может быть кодом символа
                li.
                    #[code EOF] - целая константа, определенная в &lt;stdio.h&gt; и имеющая тип int (в большинстве реализаций
                    стандартной библиотеки эта константа равна #[code -1], но для переносимости кода следует использовать именно имя #[code EOF])
                li Нужно помнить, что знаковость типа #[code char] не определена по стандарту
        section.slide
            h2 Посимвольное чтение и запись
            ul
                li #[code char c = getchar();]  - #[b неправильно], патаемся записать 257 значений в тип, максимальная вместимость которого 256
                li #[code int c = getchar();]  - #[b правильно]
                li Функции вывода интерпретируют полученный символ (типа #[code int]) как #[code unsigned char]
        section.slide
            h2 Специальные символы
            ul
                li #[code '\n'] - символ перевода новой строки,
                li #[code '\r'] - символ возврата каретки,
                li #[code '\t'] - символ табуляции,
                li #[code '\b'] - символ забоя (backspace),
                li #[code '\\'] - собственно, символ обратной косой черты,
                li #[code '\''] - одинарная кавычка (апостроф),
                li #[code '\"'] - двойная кавычка.
        section.slide
            h2 Построчный ввод
            ul
                li #[code fgets] - позволяют вводить последовательность символов из входного потока до достижения символа конца строки \n или до конца файла (что наступит раньше)
                li Функция заполняет буфер фиксированного размера, параметры которого передаются этой функции
                li Более подробное рассмотрение отложим до рассмотрения темы строк
        section.slide
            h2 Форматированный ввод-вывод
            ul
                li Позволяют преобразовывать значения между внутренним представлением и текстовыми последовательностями, которые могут быть прочитаны и записаны
                li Функции печати, объявленные в заголовочном файле #[code &lt;stdio.h&gt;], преобразуют внутреннее представление в последовательности типа char и
                   | позволяют комбинировать последовательности для вывода. К этой группе относятся, например, функции #[code fprintf], #[code printf], #[code sprintf], #[code snprintf]
        section.slide
            h2 Форматированный ввод-вывод
            ul
                li Функции сканирования, объявленные в #[code &lt;stdio.h&gt;], преобразуют последовательности типа char и позволяют сканировать считываемые последовательности.
                   | К этой группе относятся функции #[code fscanf], #[code scanf], #[code sscanf]
        section.slide
            h2 Форматированный ввод-вывод
            ul
                li Один из недостатков - #[b типонебезопасность], т.е. можно передать аргументы для ввода-вывода, не соотвествующие по количеству или по типам переданной форматной строке
                li #[code -Wformat] - включает проверку формата и аргументов, включается также #[code -Wall] (чтобы было ошибкой, надо использовать #[code -Werror])
        section.slide
            h2 Задание форматирования
            ul
                li Для задания форматирования используют символ процента и следующий за ним спецификатор
                li #[a(href="https://ejudge.ru/study/3sem/formatio.pdf") Полное описание правил форматирования]
        section.slide
            h2 Форматированный вывод
            pre
                code(style="font-size: 16pt;").
                    #include &lt;stdio.h&gt;

                    int printf(const char *format, ...);
                    int fprintf(FILE *stream, const char *format, ...);
                    int sprintf(char *str, const char *format, ...);
                    int snprintf(char *str, size_t size, const char *format, ...);
        section.slide
            h2 Форматированный ввод
            pre
                code(style="font-size: 16pt;").
                    #include &lt;stdio.h&gt;

                    int scanf(const char *format, ... );
                    int fscanf(FILE *stream, const char *format, ... );	
                    int sscanf(const char *s, const char *format, ... );
        section.slide
            h2 Форматированный ввод
            p Функция форматирования завершает работу при следующих условиях
            ul
                li Она достигает конца форматиной строки
                li Она не может получить очередной символ входного текста
                li Перобразование заканчивается неудачей (ошибка сопоставления)
            p В случае успеха возвращается число обработанных аргументов, или ноль, если был неуспешным разбор самого первого аргумента
        section.slide
            h2 Файловый ввод-вывод
            pre
                code(style="font-size: 16pt;").
                    #include &lt;stdio.h&gt;

                    FILE *fopen(const char *filename, const char *mode);
                    int fclose(FILE *stream);
        section.slide
            h2 Файловый ввод-вывод
            ul
                li r - открытие файла на чтение
                li w - открытие файла на запись, при этом если файл существовал, то содержимое его удаляется (т.е. обнуляется длина файла), если же файл не существовал, то он создается
                li a - открытие файла на запись в конец; если файл не существовал, он создается
                li r+ - открытие на чтение и запись
        section.slide
            h2 Файловый ввод-вывод
            ul
                li w+ - открытие на чтение и запись с обнулением длины существующего файла или созданием нового файла
                li a+ - открытие на чтение и запись в конец файла, если файл не существовал, он создается
            p Дополнительно может задаваться символ b в строке mode (открывается бинарный файл, не играет роли в *nix-системах, но имеет значение при работе в Windows-системах)
        section.slide
            h2 Буферизация вывода
            p Все выводимые символы предварительно сохраняются в буфере вывода, и выводятся на терминал в одном из случаев (построчная буферизация):
            ul
                li Буфер переполнен (как правило, его размер не менее 4 килобайт)
                li Работа программы завершилась
                li Вывод в поток содержит символ перевода строки '\n'
                li Вызвана функция чтения с терминала, например, #[code scanf]
                li Буфер принудительно сброшен с помощью функции #[code fflush]
        section.slide
            h2 Буферизация вывода
            p Если стандартный поток вывода перенаправлен в файл или в канал, или данные выводятся в файл (полная буферизация):
            ul
                li Буфер переполнен (как правило, его размер не менее 4 килобайт)
                li Работа программы завершилась
                li Буфер принудительно сброшен с помощью функции #[code fflush]
            p Принципиальное отличие стандартного потока stderr от stdout заключается в отсутствии буферизации
        section.slide
            h2 Буферизация ввода
            ul
                li Например, функция #[code getchar] пытается считать со стандартного потока ввода сразу блок данных размером буфера ввода
                li Функция fflush применима к некоторым входным потокам. Она пытается вернуть пока непрочитанную часть входного буфера обратно в файл. Ни к терминалам, ни к каналам эта функция неприменима (в будущем будем считать это ошибкой)
        section.slide
            h2 Управление буферизацией
            p Можно настраивать буферизацию файловых потоков с помощью #[code setbuf], #[code setbuffer], #[code setlinebuf], #[code setvbuf]
        section.slide
            h2 Потокобезопасность
            ul
                li Потокобезопасность имеет свою цену, но в однопоточных программах она не нужна
                li #[code *_unlocked] - скорость таких функций превосходит не-unlocked аналоги
                li Не стандартная библиотека C (но по стандарту POSIX)
    
        div(class="progress")
        script(src="../../../common/shower/shower.min.js")