<!DOCTYPE html><html lang="en"><head><title>Архитектура компьютера и операционные системы</title><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../../common/shower/themes/ribbon/styles/screen-16x10.css"><style type="text/css">.caption {
    color: #FFF;
}</style></head><body class="shower list"><header class="caption"><h1>Архитектура компьютера и операционные системы</h1><p>Семинар 7. Тестирование программ. Указатели на функции</p></header><section id="cover" class="slide"><h2>Семинар 7. Тестирование программ. Указатели на функции</h2><p>Архитектура компьютера и операционные системы @ ВШЭ, 2018-2019</p><img src="./img/cover.jpg" alt="" class="cover"><style type="text/css">#cover h2 {
    margin: 30px 0 0;
    color: #FFF;
    text-align: center;
    font-size: 70px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p {
    margin: 10px 0 0;
    text-align: center;
    color: #FFF;
    font-style: italic;
    font-size: 20px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p a {
    color: #FFF;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}</style></section><section class="slide"><h2>Ошибки в программах</h2><ul><li>Ошибки в логике работы программы (алгоритме)</li><li>Ошибки технического плана (неправильная работа с памятью, неправильное использование стандартной библиотеки, ...)</li></ul></section><section class="slide"><h2>Тестирование логики работы программы</h2><ul><li>Набор входных данных и правильных ответов</li><li>Входные данные должны покрывать весь набор условий задачи</li><li>Если нет четких ограничений на входные данные (большинство реальных программ) - в тестах должны быть мусорные данные</li><li>Тесты должны покрывать все ветки исполнения программы (code coverage)</li></ul></section><section class="slide"><h2>Тестирование логики работы программы</h2><ul><li>Сформулированные выше правила не дают 100% гарантии на покрытие всех возможных случаев</li><li>В реальной жизни постоянный цикл (найдена ошибка) -> (написан тест) -> (ошибка исправлена)</li></ul></section><section class="slide"><h2>Code coverage</h2><ul><li>Простой индикатор покрытия тестами</li><li>Позволяет найти участки кода, работа которых не проверяется тестами</li><li>Не проверяет покрытие тестами предметной области - гнаться только за code coverage нельзя</li></ul></section><section class="slide"><h2>Fuzzing</h2><ul><li>Фа́ззинг (англ. fuzzing) — техника тестирования программного обеспечения, часто автоматическая или полуавтоматическая, заключающая в передаче приложению на вход неправильных, неожиданных или случайных данных.</li><li>Полезно для тестирования работы на некорректных данных</li><li>Однако, можно подавать случайные корректные данные на вход, считая правильный ответ простым способом</li></ul></section><section class="slide"><h2>Тестирование работы с памятью</h2><ul><li>Санитайзеры (<code>-fsanitize=address</code>)</li><li><code>valgrind --leak-check=yes</code></li><li>Запуск под дебагером (<code>gdb</code> или <code>lldb</code>)</li></ul></section><section class="slide"><h2>Тестирование программы</h2><ul><li>Проверяйте программу специальными инструментами на наличие проблем с памятью (и не только)</li><li>Тестируйте все ветки исполнения программы</li><li>Для пошагового исполнения программы используйте дебагер</li><li>Куча <code>printf</code> тоже бывает полезна!</li></ul></section><section class="slide"><h2>Квалификатор <code>const</code></h2><ul><li>Квалификатор <code>const</code> означает, что определяемый объект не может быть модифицирован</li><li>Переменная, описанная с квалификатором <code>const</code>, не может быть использована в константных выражениях, которые, в частности, задают количество элементов массива</li><li>Правильный, хотя и не очень эстетичный способ определения констант периода компиляции в C — ключевое слово <code>enum</code></li></ul></section><section class="slide"><h2>Деклараторы</h2><ul><li>Конструкции, модифицирующие тип, такие как указатели, массивы, функции комбинируются в синтаксической конструкции, называемой «декларатором»</li><li><code>double *ptr[10];</code></li><li>Декларатор можно рассматривать как некоторое выражение над типом. В таком выражении есть три операции: [], (), *</li></ul></section><section class="slide"><h2>Указатели на функции</h2><ul><li><code>int (*pfunc)(int, int);</code> - указатель на функцию с двумя аргументами типа <int></int> и возвращаемым значением типа <int></int></li><li>Любая переменная-указатель на функцию может принимать значение NULL</li><li>Указатель должен указывать на совместимую по сигнатуре функцию</li><li>Для имен функций автоматически выполняется неявное взятие адреса и разыменовывание</li></ul></section><section class="slide"><h2><code>typedef</code></h2><ul><li>Позволяет дать типу (обычно, сложному) другое название</li><li><code>typedef int* pint;</code> - <code>pint</code> - синоним для <code>int*</code></li><li>Используется для обобщенных алгоритмов и не только</li><li>Лайфхак: <code>typedef struct A { ... } A</code> и можно не писать <code>struct</code> перед <code>A</code></li></ul></section><div class="progress"></div><script src="../../../common/shower/shower.min.js"></script></body></html>