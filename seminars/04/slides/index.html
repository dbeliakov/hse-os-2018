<!DOCTYPE html><html lang="en"><head><title>Архитектура компьютера и операционные системы</title><meta charset="utf-8"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="stylesheet" href="../../../common/shower/themes/ribbon/styles/screen-16x10.css"><style type="text/css">.caption {
    color: #FFF;
}</style></head><body class="shower list"><header class="caption"><h1>Архитектура компьютера и операционные системы</h1><p>Семинар 4. Вещественные типы данных</p></header><section id="cover" class="slide"><h2>Семинар 4. Вещественные типы данных</h2><p>Архитектура компьютера и операционные системы @ ВШЭ, 2018-2019</p><img src="./img/cover.jpg" alt="" class="cover"><style type="text/css">#cover h2 {
    margin: 30px 0 0;
    color: #FFF;
    text-align: center;
    font-size: 70px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p {
    margin: 10px 0 0;
    text-align: center;
    color: #FFF;
    font-style: italic;
    font-size: 20px;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}
#cover p a {
    color: #FFF;
    text-shadow: black 1px 1px 0, black -1px -1px 0, 
                 black -1px 1px 0, black 1px -1px 0;
}</style></section><section class="slide"><h2>Фиксированная точка</h2><img src="img/fixed.gif"><ul><li>Фиксированное количество бит на целую и дробную части</li><li>Пример: <code>2.5 = 0010.1000</code></li><li>Содержит ошибки в силу конечного числа бит. Ошибка не превышает половины веса младшего разряда (напр., 0.03125 для 8 бит)</li></ul></section><section class="slide"><h2>Фиксированная точка</h2><ul><li>Сложение и вычитание - как целые числа</li><li>Умножение: 16-битный результат округляем до 8 бит</li><li>Деление: дополняем нулями до 16 бит и делим как целые, округляем</li><li>Округление по умолчанию - к ближайшему четному, четное - младший значащий бит = 0</li></ul></section><secton class="slide"><h2>Плавающая точка</h2><ul><li>Стандарт IEEE 754, поддерживается во всех основных архитектурах (если нет - программаная реализация)</li><li>Появление обусловлено требованиями числовых расчетов</li><li>Компромисс между точностью и диапазоном принимаемых значений</li><li>Аналог экспоненциальной записи чисел, но только в памяти компьютера</li></ul></secton><section class="slide"><h2>Плавающая точка</h2><img src="img/float.png" style="width: 80%"><ul><li>(−1)^S×M×B^E, где S — знак, B — основание (2), E — порядок (экспонента, показатель степени), а M — мантисса</li></ul></section><section class="slide"><h2>Плавающая точка</h2><ul><li>Половинная точность - занимает в памяти половину машинного слова</li><li>Одинарная точность - занимает в памяти машинное слово</li><li>Двойная точность - занимает в памяти два машинных слова</li></ul></section><section class="slide"><h2>Плавающая точка</h2><ul><li>Порядок записывается как целое число в коде со сдвигом (сдвиг 2^b - 1, где b - число бит порядка)</li><li>Мантисса кодируется со "скрытой" единицей</li></ul></section><section class="slide"><h2>Нормализованная форма</h2><ul><li>Мантисса принимает значения от 1.xxxxxxx (аналог 1.xxx-9.xxx для десятичных)</li><li>Любое число (кроме 0) записывается единственным образом</li><li>Ноль представить в таком виде невозможно</li><li>Старший бит не записывается (но всегда учитывается)</li></ul></section><section class="slide"><h2>Денормализованная форма</h2><ul><li>Порядок записывается как целое число в коде со сдвигом</li><li>Каждое значение денормализованного числа меньше самого маленького нормализованного значения</li><li>Порядок - все биты равны нулю</li><li>Мантисса - ненулевая</li><li>Тогда считается, что порядок - на единицу больше, а старший бит мантиссы - 0</li></ul></section><section class="slide"><h2>Денормализованная (субнормальная) форма</h2><ul><li>Ввиду сложности денормализованные числа крайне редко реализуют на аппаратном уровне - вместо этого используются программные реализации, работающие значительно медленнее</li><li>Т.к. денормализованные числа получаются действительно очень маленькими и практически никак не влияют на результат некоторых вычислений, часто они игнорируются</li><li>Flush-to-zero (FTZ) и Denormals-are-zero (DAZ)</li></ul></section><section class="slide"><h2>Специальные значения</h2><ul><li>Число считается нулём, если все его биты, кроме знакового, равны нулю</li><li>NaN представлен как число, в котором все двоичные разряды порядка — единицы, а мантисса не нулевая</li><li>Число с плавающей запятой считается равным бесконечности, если все двоичные разряды его порядка — единицы, а мантисса равна нулю. Знак бесконечности определяется знаковым битом числа</li></ul></section><section class="slide"><h2>Умножение и деление</h2><ul><li>Умножение в нормализованной форме - перемножить мантиссы, сложить порядки, округлить и нормализовать полученное число</li><li>Деление в нормализованной форме - разделить мантиссу делимого на мантиссу делителя и вычесть из порядка делимого порядок делителя, округлить и нормализовать</li></ul></section><section class="slide"><h2>Сложение и вычитание</h2><ul><li>Идея - приведение чисел к одному порядку</li><li>Сначала выбирается оптимальный порядок, затем мантиссы обоих чисел представляются в соответствии с новым порядком, затем над ними производится сложение/вычитание, мантисса результата округляется и, если нужно, результат приводится к нормализированной форме</li></ul></section><section class="slide"><h2>Свойства операций</h2><ul><li>Сложение не ассоциативно: <code>(a + b) + c != a + (b + c)</code></li><li>Умножение не ассоциативно: <code>(a * b) * c != a * (b * c)</code></li><li>Умножение не дистрибутивно: <code>a * (b + c) != a * b + a * c</code></li></ul></section><section class="slide"><h2>Unit in the last place</h2><ul><li>a, b - ближайшие друг к другу представимые числа, a &lt; b, ULP = b - a</li><li>Если a = 1, то ULP - машинный эпсилон</li><li>Во <code>float.h</code> - <code>FLT_EPSILON</code>, <code>DBL_EPSILON</code>, <code>LDBL_EPSILON</code></li><li>Сравнение на равенство чисел с плавающей запятой - только через неравенство</li></ul></section><section class="slide"><h2>Получение представления вещественного числа</h2><ul><li>Перевести модуль данного числа в двоичную систему счисления</li><li>Нормализовать двоичное число</li><li>Прибавить к порядку смещение и перевести смещенный порядок в двоичную систему счисления</li><li>Учитывая знак заданного числа, выписать его представление в памяти</li></ul></section><div class="progress"></div><script src="../../../common/shower/shower.min.js"></script></body></html>